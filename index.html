<!DOCTYPE html>
<html>
    <head>
        <title>Flappy2.0</title>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no">

        <style>
            canvas {
                display: block;
                position: absolute;
                margin: auto;
                top: 0;
                bottom: 0;
                left: 0;
                right: 0;
            }
    
        </style>
    </head>
    
    <body>
        <canvas id="static" style="z-index: 0;"></canvas>
        <canvas id="dynamic" style="z-index: 1;"></canvas>
        <canvas id="ui" style="z-index: 2;"></canvas>

        <div id="PlayButton"></div>

        <script>
            const FIXED_DELTA_TIME = 1.0/60.0;

            const GRAVITY = 300;
            
            const PLANE_CIRCLE_COLLISION_RADIUS = 50;
            // The velocity change on touch/mouse press
            const PLANE_JUMP_VELOCITY = 250;
            // The speed at which the world scrolls
            const PLANE_SPEED = 100;
            // As the plane sprite is pretty big by itself
            const PLANE_SCALE = 0.55;
            // Additional offset from the middle to give player more view
            const PLANE_OFFSET = 50;
            // Defines the duration of the whole animation 
            const PLANE_ANIMATION_SPEED = 0.2;

            // CanvasWidth is normal distance, this is applied to it
            const SPIKE_DISTANCE_FACTOR = 0.8;
            // How much the spikes can vary in gap
            const SPIKE_GAP_RANGE = [150, 280];
            // How much the spikes can vary in height
            const SPIKE_HEIGHT_RANGE = [-50, 100];

            // Used to render moving images (redrawn)
            var gDynamicContext;
            // Used to render static images
            var gStaticContext;
            // Used for displaying the HUD and menus
            var gUIContext;
            // The sprite sheet
            var gSheet;

            // Aka window width (inner)
            var gCanvasWidth;
            // Aka window height (inner)
            var gCanvasHeight;
            // Used to scale all images (height defines width)
            var gCanvasAspectRatio;

            // The ground sprite
            var gGround;
            // The x position of the currently visible ground
            var gGroundPosX = 0;
            // The x position of the "next" ground
            var gNextGroundPosX = 0;

            // The plane of the player
            var gPlane;


            var gButtonPlay;
            var gButtonLarge;
            var gLetterP;
            var gLetterL;
            var gLetterA;
            var gLetterY;

            // Spikes
            var gSpikeUp;
            var gSpikeDown;

            // Left, middle and right spikes
            var gSpikes = [];
            var gSpikeDistance = 0;

            const GameState = {
                NONE: 0,
                START_MENU: 1,
                PLAYING: 2,
                GAME_OVER: 3
            }

            var gGameState = GameState.START_MENU;
            var gPrevGameState = GameState.NONE;

            // Wait for window to load before starting
            window.onload = function() {
                main();
            }

            function main(){
                // Get window size
                gCanvasWidth = window.innerWidth;
                gCanvasHeight = window.innerHeight;

                // Setup static canvas for background
                var staticCanvas = document.getElementById("static");
                staticCanvas.width = gCanvasWidth;
                staticCanvas.height = window.innerHeight;
                gStaticContext = staticCanvas.getContext("2d");

                // Setup dynamic canvas for moving objects
                var dynamicCanvas = document.getElementById("dynamic");
                dynamicCanvas.width = gCanvasWidth;
                dynamicCanvas.height = gCanvasHeight;
                gDynamicContext = dynamicCanvas.getContext("2d");

                // Setup UI canvas for displaying HUD and menus
                var uiCanvas = document.getElementById("ui");
                uiCanvas.width = gCanvasWidth;
                uiCanvas.height = gCanvasHeight;
                gUIContext = uiCanvas.getContext("2d");

                // Mouse events
                window.onmousedown = function(mouse){
                    onMouseClick(mouse);
                }

                // Load sprite sheet
                sheet = new Image();
                sheet.onload = function(){
                    runGame();
                }
                sheet.src = "sheet.png";
            }

            function getTimestamp(){
                return window.performance ? window.performance.now() : Date.now();
            }

            function runGame(){
                // As the background sprite has to cover everything, it defines the aspect ratio
                var backgroundHeight = 480;
                gCanvasAspectRatio = gCanvasHeight / backgroundHeight;
                console.log(gCanvasAspectRatio);

                // Add static background
                var backgroundSprite = new Sprite(sheet, 0, 355, 800, 480, gCanvasAspectRatio);
                backgroundSprite.draw(gStaticContext, 0, 0);

                // Ground that will be moving to simulate movement
                gGround = new Sprite(sheet, 0, 0, 807, 71, gCanvasAspectRatio);
                // Move the second ground to start position
                gNextGroundPosX = gGround.width * gCanvasAspectRatio;

                // Get animation frames for plane
                var plane_frame1 = new Sprite(sheet, 330, 1371, 88, 73, gCanvasAspectRatio);
                var plane_frame2 = new Sprite(sheet, 372, 1132, 88, 73, gCanvasAspectRatio);
                var plane_frame3 = new Sprite(sheet, 222, 1562, 88, 73, gCanvasAspectRatio);
                gPlane = new Plane(plane_frame1, plane_frame2, plane_frame3, PLANE_ANIMATION_SPEED);

                // Play button sprites
                gButtonLarge = new Sprite(sheet, 0, 1250, 196, 70, gCanvasAspectRatio);
                gLetterP = new Sprite(sheet, 489, 1427, 48, 65, gCanvasAspectRatio);
                gLetterL = new Sprite(sheet, 512, 899, 44, 64, gCanvasAspectRatio);
                gLetterA = new Sprite(sheet, 412, 835, 61, 64, gCanvasAspectRatio);
                gLetterY = new Sprite(sheet, 432, 1473, 57, 64, gCanvasAspectRatio);

                // Spikes
                gSpikeUp = new Sprite(sheet, 0, 1757, 108, 239, gCanvasAspectRatio);
                gSpikeDown = new Sprite(sheet, 265, 986, 106, 238, gCanvasAspectRatio);
                
                gSpikeDistance = gCanvasWidth * SPIKE_DISTANCE_FACTOR;

                setupSpikes();

                var last = getTimestamp();
                let deltaAccumulator = 0;
                // Main loop
                var loop = function(timestamp){

                    updateGameState();

                    // If performance is supported, use it
                    var now = getTimestamp();
                    var delta = (now - last) / 1000.0;
                    last = now;
                    deltaAccumulator += delta;

                    while(deltaAccumulator >= FIXED_DELTA_TIME){
                        update(FIXED_DELTA_TIME);
                        deltaAccumulator -= FIXED_DELTA_TIME;
                    }

                    render(delta);
                    window.requestAnimationFrame(loop)
                }
                window.requestAnimationFrame(loop)
            }

            function updateGameState() {
                // Start of game
                if(gGameState == GameState.START_MENU && gPrevGameState != GameState.START_MENU){
                    addPlayButton();
                    gPrevGameState = gGameState;
                }
                // Player died
                if(gGameState == GameState.GAME_OVER && gPrevGameState == GameState.PLAYING){
                    addPlayButton();
                    gPrevGameState = gGameState;
                }

                // Player pressed start
                if(gGameState == GameState.PLAYING && gPrevGameState != GameState.PLAYING){
                    resetGame();
                    clearUICanvas();
                    gPrevGameState = gGameState;
                }
            }

            function update(delta){
                // Pause everything in GameOver screen
                if(gGameState == GameState.GAME_OVER){
                    return;                    
                }

                // Only move world if player isn't dead
                if(!gPlane.dead){
                    // Move along x
                    gPlane.worldPosX += PLANE_SPEED * delta;
                }

                // If the current ground is out of view, update positions
                if(gPlane.worldPosX > gNextGroundPosX){
                        gGroundPosX = gNextGroundPosX;
                        gNextGroundPosX = gNextGroundPosX + gGround.width * gCanvasAspectRatio;
                }

                // Nothing to do if player isn't playing
                if(gGameState != GameState.PLAYING){
                    return;
                }
                
                // Update player physics
                gPlane.update(delta);

                // Nothing to do if player died
                if(gPlane.dead){
                    return;
                }

                // If player reached middle spike, move left to right
                if(gPlane.worldPosX > gSpikes[1].x){
                    var newRightSpike = gSpikes[0];
                    gSpikes[0] = gSpikes[1];
                    gSpikes[1] = gSpikes[2];
                    // Give it new height and gap
                    newRightSpike.setRandomGapAndHeight(SPIKE_GAP_RANGE, SPIKE_HEIGHT_RANGE);
                    newRightSpike.x += gSpikeDistance * 3;
                    gSpikes[2] = newRightSpike;
                }

                // Check if player is colliding with 
                gSpikes.forEach(spike => {
                    let planeX = gPlane.posX + gPlane.plane_frames[0].width / 2 * gCanvasAspectRatio / 2
                    let planeY = gPlane.posY + gPlane.plane_frames[0].height / 2 * gCanvasAspectRatio / 2
                    if(spike.isCollidingWithCircle(planeX, planeY, PLANE_CIRCLE_COLLISION_RADIUS, gPlane.worldPosX)){
                        gPlane.dead = true;
                        gPlane.velocity = 0;
                        return;
                    }
                });
            }
            
            function render(delta){              
                // Remove everything from dynamic canvas
                gDynamicContext.clearRect(0,0, gCanvasWidth, gCanvasHeight);

                if(gGameState != GameState.START_MENU){
                    renderSpikes(gDynamicContext);
                }

                renderGrounds(gDynamicContext);
                renderPlane(gDynamicContext, delta);
            }

            function renderGrounds(context){
                // Draw current ground
                gGround.draw(context, gGroundPosX - gPlane.worldPosX, gCanvasHeight - gGround.height * gCanvasAspectRatio);
                // Draw ground out of view
                gGround.draw(context, gNextGroundPosX - gPlane.worldPosX, gCanvasHeight - gGround.height * gCanvasAspectRatio);
            }

            function renderPlane(context, delta){
                gPlane.draw(context, PLANE_SCALE, delta);
            }

            function renderSpikes(context) {
                gSpikes.forEach(spike => {
                    spike.draw(context, gPlane.worldPosX);
                });
            }

            // Resets all necessary variables
            function resetGame() {
                setupSpikes();
                gGroundPosX = 0;
                gNextGroundPosX = gGround.width * gCanvasAspectRatio;
                gPlane.reset();
            }

            function setupSpikes() {
                gSpikes.length = 0;
                // Add three spikes, 2 visible at once, one can be moved
                let spike = new Spike(gSpikeUp, gSpikeDown, gCanvasWidth);
                spike.setRandomGapAndHeight(SPIKE_GAP_RANGE, SPIKE_HEIGHT_RANGE);
                gSpikes.push(spike);
                spike = new Spike(gSpikeUp, gSpikeDown,  gCanvasWidth + gSpikeDistance);
                spike.setRandomGapAndHeight(SPIKE_GAP_RANGE, SPIKE_HEIGHT_RANGE);
                gSpikes.push(spike);
                spike = new Spike(gSpikeUp, gSpikeDown, gCanvasWidth + gSpikeDistance * 2);
                spike.setRandomGapAndHeight(SPIKE_GAP_RANGE, SPIKE_HEIGHT_RANGE);
                gSpikes.push(spike);

                gSpikePosX = gCanvasWidth;
                gNextSpikePosX = gCanvasWidth + gSpikeDistance;
            }

            // Clears the UI
            function clearUICanvas(){
                gUIContext.clearRect(0,0, gCanvasWidth, gCanvasHeight);
            }

            function addPlayButton(){
                var buttonX = gCanvasWidth / 2 - (gButtonLarge.width / 2 * gCanvasAspectRatio / 2);
                var buttonY = gCanvasHeight / 2;
                var buttonScale = 0.5;
                var buttonWidth = gButtonLarge.width * gCanvasAspectRatio * buttonScale;
                var buttonHeight = gButtonLarge.height * gCanvasAspectRatio * buttonScale;
                
                gButtonPlay = new Button(buttonX, buttonY, buttonWidth, buttonHeight)
                gButtonLarge.draw(
                        gUIContext, 
                        buttonX, 
                        buttonY, 
                        buttonScale
                    );
                    gLetterP.draw(
                        gUIContext,
                        gCanvasWidth / 2 - (gButtonLarge.width / 2 * 0.95 * gCanvasAspectRatio / 2),
                        gCanvasHeight / 2, 
                        buttonScale
                    );
                    gLetterL.draw(
                        gUIContext,
                        gCanvasWidth / 2 - (gButtonLarge.width / 2 * 0.5 * gCanvasAspectRatio / 2),
                        gCanvasHeight / 2, 
                        buttonScale
                    );
                    gLetterA.draw(
                        gUIContext,
                        gCanvasWidth / 2 - (gButtonLarge.width / 2 * 0.05 * gCanvasAspectRatio / 2),
                        gCanvasHeight / 2, 
                        buttonScale
                    );
                    gLetterY.draw(
                        gUIContext,
                        gCanvasWidth / 2 + (gButtonLarge.width / 2 * 0.4 * gCanvasAspectRatio / 2),
                        gCanvasHeight / 2, 
                        buttonScale
                    );
            }

            function onMouseClick(mouse){
                if(gGameState == GameState.PLAYING){
                    gPlane.jump();
                }

                if(gGameState == GameState.START_MENU || gGameState == GameState.GAME_OVER){
                    if(gButtonPlay.isInside(mouse.clientX, mouse.clientY)){
                        gGameState = GameState.PLAYING;
                    }
                }
            }

            // A sprite consists of an image, size and position
            class Sprite{
                constructor(image, x, y, width, height, aspectRatio){
                    this.image = image;
                    this.x = x;
                    this.y = y;
                    this.width = width;
                    this.height = height;
                    this.aspectRatio = aspectRatio
                }

                // Draws the image at the specified pixel position
                draw(context, x, y, scale = 1){
                    context.drawImage(
                        this.image, 
                        this.x, 
                        this.y, 
                        this.width, 
                        this.height, 
                        x, 
                        y, 
                        this.width * this.aspectRatio * scale, 
                        this.height * this.aspectRatio * scale)
                }
            }

            class Button{
                constructor(x, y, width, height){
                    this.x = x;
                    this.y = y;
                    this.width = width;
                    this.height = height;
                }
                
                isInside(mouseX, mouseY){
                    return  mouseX >= this.x && mouseX <= this.x + this.width &&
                            mouseY >= this.y && mouseY <= this.y + this.height;
                }
            }

            class Spike{
                constructor(spikeUp, spikeDown, x){
                    this.spikeUp = spikeUp;
                    this.spikeDown = spikeDown;
                    this.x = x;
                    this.gap = 0;
                    this.height_offset = 0;
                }

                draw(context, x){
                    this.spikeDown.draw(
                        context, 
                        this.x - x, 
                        -this.gap / 2 - this.height_offset
                    );
                    this.spikeUp.draw(
                        context, 
                        this.x - x, 
                        gCanvasHeight - this.spikeUp.height * gCanvasAspectRatio + this.gap / 2 - this.height_offset
                    );

                    let spikeDownX = this.x - x + this.spikeDown.width;
                    let spikeDownY = -this.gap / 2 - this.height_offset + this.spikeDown.height * gCanvasAspectRatio;
                    let spikeUpX = this.x - x + this.spikeUp.width;
                    let spikeUpY = gCanvasHeight - this.spikeUp.height * gCanvasAspectRatio + this.gap / 2 - this.height_offset;
                    gDynamicContext.beginPath();
                    gDynamicContext.arc(spikeDownX, spikeDownY, 10, 0, 2 * Math.PI);
                    gDynamicContext.stroke();
                    gDynamicContext.beginPath();
                    gDynamicContext.arc(spikeUpX, spikeUpY, 10, 0, 2 * Math.PI);
                    gDynamicContext.stroke();
                }

                setRandomGapAndHeight(gapMinMax, heightMinMax){
                    this.gap = this.randomBetween(gapMinMax[0], gapMinMax[1]);
                    this.height_offset = this.randomBetween(heightMinMax[0], heightMinMax[1]);
                }

                randomBetween(min, max) {
                    return Math.random() * (max - min) + min;
                }

                isCollidingWithCircle(x, y, r, worldPosX){
                    // Check spike tip
                    let spikeDownX = this.x - x + this.spikeDown.width;
                    let spikeDownY = -this.gap / 2 - this.height_offset + this.spikeDown.height * gCanvasAspectRatio;
                    let spikeUpX = this.x - x + this.spikeUp.width;
                    let spikeUpY = gCanvasHeight - this.spikeUp.height * gCanvasAspectRatio + this.gap / 2 - this.height_offset;
                    
                    if(Math.pow(spikeDownX - worldPosX, 2) + Math.pow(spikeDownY - y, 2) < (r * r) ||
                        Math.pow(spikeUpX - worldPosX, 2) + Math.pow(spikeUpY - y, 2) < (r * r)){
                        return true;
                    }
                }
            }

            // Player controlled image
            // Contains an animation and positions
            class Plane{
                constructor(plane_frame1, plane_frame2, plane_frame3, animationSpeed){
                    this.plane_frames = [];
                    this.plane_frames.push(plane_frame1);
                    this.plane_frames.push(plane_frame2);
                    this.plane_frames.push(plane_frame3);
                    this.currentFrameIndex = 0;
                    this.worldPosX = 0;
                    this.startX = gCanvasWidth / 2 - plane_frame1.width / 2 - PLANE_OFFSET;
                    this.startY = gCanvasHeight / 3;
                    this.posX = this.startX;
                    this.posY = this.startY;
                    this.animationAccumulator = 0;
                    this.animationStep = animationSpeed / this.plane_frames.length;

                    this.velocity = 0;
                    this.dead = false;
                }

                reset(){
                    this.currentFrameIndex = 0;
                    this.worldPosX = 0;
                    this.posX = this.startX;
                    this.posY = this.startY;
                    this.animationAccumulator = 0;
                    this.velocity = 0;
                    this.dead = false;
                }

                update(delta){
                    // Apply velocity to y
                    this.posY += this.velocity * delta;
                    // Add gravity
                    this.velocity += GRAVITY * delta;

                    if(this.posY > gCanvasHeight - gGround.height * gGround.aspectRatio){
                        this.die();
                    }
                }

                draw(context, scale, delta){
                    // Only stop animation if in game over screen
                    if(gGameState != GameState.GAME_OVER){
                        this.animationAccumulator += delta;
                        if(this.animationAccumulator >= this.animationStep){
                            this.currentFrameIndex = ++this.currentFrameIndex % this.plane_frames.length;
                            this.animationAccumulator -= this.animationStep
                        }
                    }

                    var currentFrame = this.plane_frames[this.currentFrameIndex];
                    currentFrame.draw(context, this.posX, this.posY, scale);
                    gDynamicContext.beginPath();
                    gDynamicContext.arc(this.posX + this.plane_frames[0].width / 2 * gCanvasAspectRatio / 2, 
                                        this.posY + this.plane_frames[0].height / 2 * gCanvasAspectRatio / 2, 
                                        PLANE_CIRCLE_COLLISION_RADIUS, 0, 2 * Math.PI);
                    gDynamicContext.stroke();
                }

                die(){
                    // Reset velocity
                    this.velocity = 0;
                    this.dead = true;
                    // Tell game that player died
                    gGameState = GameState.GAME_OVER;
                }

                jump(){
                    if(this.dead){
                        return;
                    }
                    // Prevent player from flying to the moon
                    if(gPlane.posY > 0){
                        gPlane.velocity = -PLANE_JUMP_VELOCITY;
                    }
                }
            }

        </script>
    </body>
</html>